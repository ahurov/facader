# facader

Библиотека должна помочь тем, кто работает с фреймворками старого образца - теми, которые используют классы нарушающие принцип единой ответственности. Точнее так - из-за отсутствия вложенных классов в PHP классы приходится разделять на классы-поведения и классы-данные. По задумке ООП эти вещи могут располагаться в одном классе, однако это убирает возможность замены одних действий другими без наследования.

Казалось бы - что плохого в наследовании? Эта проблема не возникает до тех пор, пока мы на задумываемся о раскладывании проекта на несколько машин и переписывании программы на заменяемые модули. Модуль требует строго определенных вещей, и если эти вещи всячески наследуют внешние библиотеки и заменяют их, то каждый модуль будет тянуть за собой всю программу и перестанет быть модулем.

Обычно в этих фреймворках используются статические обращения к синглтонам и другим классам, а подбросить зависимость в конструктор попросту невозможно - в конструкторе уже находятся данные в качестве зависимости, и оборачивать весь код в инжектор зависимостей это не минутное дело.

Laravel для этих целей предлагает статические фасады - они оборачивают некий класс в декоратор и с помощью методов `__call` и `__callStatic` вызывают его функции, предварительно создав обьект в инжекторе. Однако, проведя несколько измерений скорости было выяснено, что такой способ вызова в 10 раз медленнее прямого вызова метода класса.

Таким образом, Фасадер создает из указанных классов и указанного контейнера новый файл класса, где все методы статические и проброшены через создание экземпляра контейнером.

Я не рекомендую злоупотреблять этим способом работы, потому что статические обращения к именам классов усложняют дальнейшую замену этих классов на другие - если вы подмените экземпляр в Фасаде - он подменится во всем вашем коде, что может привести к ошибкам. Старайтесь использовать внедрение зависимости через конструктор (используя лучше Интерфейс в качестве ожидаемого аргумента), но если уж совсем никак - помните, что статический Фасад подобно интерфейсу должен быть один для одного места в коде, и заменен на второй фасад, если поведение будет доработано.

Таким образом - создание трех классов фасадов для одного сервиса это нормально, иначе смысл подменяемости будет утерян.
